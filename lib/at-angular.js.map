{"version":3,"sources":["at-angular.ts"],"names":["at","at.attachInjects","at.getOrCreateModule","at.inject","at.injectMethod","at.service","at.provider","at.filter","at.filter.Provider","at.filter.Provider.constructor","at.valueObj","at.valueProp","at.valueFunc","at.constantObj","at.constantProp","at.constantFunc","at.controller","at.component","at.directive"],"mappings":"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","file":"at-angular.js","sourcesContent":["module at {\n\n  'use strict';\n\n  /* tslint:disable:no-any */\n  export interface IClassAnnotationDecorator {\n    (target: any): void;\n    (t: any, key: string, index: number): void;\n  }\n\n  export interface IPropertyAnnotationDecorator {\n    (target: any, key: string): void;\n  }\n\n  export interface IMethodAnnotationDecorator {\n    (target: any, key: string, descriptor: TypedPropertyDescriptor<any>): void;\n  }\n\n  export function attachInjects(target: any, ...args: any[]): any {\n    (target.$inject || []).forEach((item: string, index: number) => {\n      target.prototype[(item.charAt(0) === '$' ? '$' : '$$') + item] = args[index];\n    });\n    return target;\n  }\n\n  /**\n   * return a module. If module doesn't exist it will be created\n   */\n  export function getOrCreateModule(moduleName: string, requires: string[] = []): angular.IModule {\n    let mod: angular.IModule;\n    try {\n      mod = angular.module(moduleName);\n    } catch (ex) {\n      mod = angular.module(moduleName, requires);\n    }\n\n    return mod;\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////\n  // INJECT ANNOTATION\n  ///////////////////////////////////////////////////////////////////////////////\n\n  export interface IInjectAnnotation {\n    (...args: any[]): IClassAnnotationDecorator;\n  }\n\n  /**\n   * inject an argument\n   */\n  export function inject(...args: string[]): at.IClassAnnotationDecorator {\n    return (target: any, key?: string, index?: number): void => {\n      if (angular.isNumber(index)) {\n        target.$inject = target.$inject || [];\n        target.$inject[index] = args[0];\n      } else {\n        target.$inject = args;\n      }\n    };\n  }\n\n  export function injectMethod(...args: string[]): at.IMethodAnnotationDecorator {\n    return (target: any, key: string, descriptor: TypedPropertyDescriptor<any>): void => {\n      target[key].$inject = args;\n    };\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////\n  // SERVICE ANNOTATION\n  ///////////////////////////////////////////////////////////////////////////////\n\n  export interface IServiceAnnotation {\n    (moduleName: string, serviceName: string): IClassAnnotationDecorator;\n  }\n\n  /**\n   * inject a service\n   */\n  export function service(moduleName: string, serviceName: string): at.IClassAnnotationDecorator {\n    return (target: any): void => {\n      getOrCreateModule(moduleName).service(serviceName, target);\n    };\n\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////\n  // PROVIDER ANNOTATION\n  ///////////////////////////////////////////////////////////////////////////////\n\n  export interface IProviderAnnotation {\n    (moduleName: string, providerName: string): IClassAnnotationDecorator;\n  }\n\n  /**\n   * inject a provider\n   */\n  export function provider(moduleName: string, providerName: string): at.IClassAnnotationDecorator {\n    return (target: any): void => {\n      getOrCreateModule(moduleName).provider(providerName, target);\n    };\n\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////\n  // FILTER ANNOTATION\n  ///////////////////////////////////////////////////////////////////////////////\n\n  export interface IFilter {\n    transform(input: any, ...args: any[]): any;\n  }\n\n  export interface IFilterAnnotation {\n    (moduleName: string, filterName: string): IClassAnnotationDecorator;\n  }\n\n  /**\n   * inject a provider\n   */\n  export function filter(moduleName: string, filterName: string): at.IClassAnnotationDecorator {\n    return (target: any): void => {\n      class Provider {\n        constructor() {\n          this.$get.$inject = (target.$inject || []).slice();\n        }\n        public $get = (...deps) => new target(...deps).transform;\n      }\n      getOrCreateModule(moduleName).provider(filterName + 'Filter', Provider);\n    };\n\n  }\n  ///////////////////////////////////////////////////////////////////////////////\n  // VALUE ANNOTATION\n  ///////////////////////////////////////////////////////////////////////////////\n\n  export interface IValueAnnotation {\n    (moduleName: string, valueName: string): IClassAnnotationDecorator;\n  }\n\n  export function valueObj(moduleName: string, valueName: string): at.IClassAnnotationDecorator {\n    return (target: any): void => {\n      getOrCreateModule(moduleName).value(valueName, target);\n    };\n  }\n\n  export function valueProp(moduleName: string, valueName?: string): at.IPropertyAnnotationDecorator {\n    return (target: any, key: string): void => {\n      getOrCreateModule(moduleName).value(valueName || key, target[key]);\n    };\n  }\n\n  export function valueFunc(moduleName: string, valueName?: string): at.IMethodAnnotationDecorator {\n    return (target: any, key: string, descriptor: TypedPropertyDescriptor<any>): void => {\n      getOrCreateModule(moduleName).value(valueName || key, target[key]);\n    };\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////\n  // CONSTANT ANNOTATION\n  ///////////////////////////////////////////////////////////////////////////////\n\n  export interface IConstantAnnotation {\n    (moduleName: string, valueName: string): IClassAnnotationDecorator;\n  }\n\n  export function constantObj(moduleName: string, valueName: string): at.IClassAnnotationDecorator {\n    return (target: any): void => {\n      getOrCreateModule(moduleName).constant(valueName, target);\n    };\n  }\n\n  export function constantProp(moduleName: string, valueName?: string): at.IPropertyAnnotationDecorator {\n    return (target: any, key: string): void => {\n      getOrCreateModule(moduleName).constant(valueName || key, target[key]);\n    };\n  }\n\n  export function constantFunc(moduleName: string, valueName?: string): at.IMethodAnnotationDecorator {\n    return (target: any, key: string, descriptor: TypedPropertyDescriptor<any>): void => {\n      getOrCreateModule(moduleName).constant(valueName || key, target[key]);\n    };\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////\n  // CONTROLLER ANNOTATION\n  ///////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @link http://angular.github.io/router/lifecycle\n   */\n  export interface IController {\n    canActivate?(): boolean | angular.IPromise<boolean>;\n    activate?(): any;\n    canDeactivate?(): boolean | angular.IPromise<boolean>;\n    deactivate?(): any;\n  }\n\n  export interface IControllerAnnotation {\n    (moduleName: string, ctrlName: string): IClassAnnotationDecorator;\n  }\n\n  /**\n   * Inject a controller\n   */\n  export function controller(moduleName: string, ctrlName: string): at.IClassAnnotationDecorator {\n    return (target: any): void => {\n      getOrCreateModule(moduleName).controller(ctrlName, target);\n    };\n\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////\n  // COMPONENT ANNOTATION\n  ///////////////////////////////////////////////////////////////////////////////\n\n  export interface OnInit {\n    $onInit(): void;\n  }\n\n  /**\n   * RouteData is an immutable map of additional data you can configure in your Route.\n   * You can inject RouteData into the constructor of a component to use it.\n   */\n  export interface RouteData {\n    data: { [key: string]: any };\n    get(key: string): any;\n  }\n\n  /**\n   * A `ComponentInstruction` represents the route state for a single component. An `Instruction` is\n   * composed of a tree of these `ComponentInstruction`s.\n   *\n   * `ComponentInstructions` is a public API. Instances of `ComponentInstruction` are passed\n   * to route lifecycle hooks, like {@link CanActivate}.\n   *\n   * `ComponentInstruction`s are [https://en.wikipedia.org/wiki/Hash_consing](hash consed). You should\n   * never construct one yourself with \"new.\" Instead, rely on {@link Router/RouteRecognizer} to\n   * construct `ComponentInstruction`s.\n   *\n   * You should not modify this object. It should be treated as immutable.\n   */\n  export interface ComponentInstruction {\n    reuse: boolean;\n    routeData: RouteData;\n    urlPath: string;\n    urlParams: string[];\n    data: RouteData;\n    componentType: any;\n    terminal: boolean;\n    specificity: number;\n    params: { [key: string]: any };\n  }\n\n  /**\n   * Defines route lifecycle method `routerOnActivate`, which is called by the router at the end of a\n   * successful route navigation.\n   *\n   * For a single component's navigation, only one of either {@link OnActivate} or {@link OnReuse}\n   * will be called depending on the result of {@link CanReuse}.\n   *\n   * The `routerOnActivate` hook is called with two {@link ComponentInstruction}s as parameters, the\n   * first\n   * representing the current route being navigated to, and the second parameter representing the\n   * previous route or `null`.\n   *\n   * If `routerOnActivate` returns a IPromise, the route change will wait until the IPromise settles to\n   * instantiate and activate child components.\n   *\n   * ### Example\n   * {@example router/ts/on_activate/on_activate_example.ts region='routerOnActivate'}\n   */\n  export interface OnActivate {\n    $routerOnActivate(next?: ComponentInstruction, prev?: ComponentInstruction): any;\n  }\n\n  /**\n   * Defines route lifecycle method `routerCanDeactivate`, which is called by the router to determine\n   * if a component can be removed as part of a navigation.\n   *\n   * The `routerCanDeactivate` hook is called with two {@link ComponentInstruction}s as parameters,\n   * the\n   * first representing the current route being navigated to, and the second parameter\n   * representing the previous route.\n   *\n   * If `routerCanDeactivate` returns or resolves to `false`, the navigation is cancelled. If it\n   * returns or\n   * resolves to `true`, then the navigation continues, and the component will be deactivated\n   * (the {@link OnDeactivate} hook will be run) and removed.\n   *\n   * If `routerCanDeactivate` throws or rejects, the navigation is also cancelled.\n   *\n   * ### Example\n   * {@example router/ts/can_deactivate/can_deactivate_example.ts region='routerCanDeactivate'}\n   */\n  export interface CanDeactivate {\n    $routerCanDeactivate(next?: ComponentInstruction, prev?: ComponentInstruction): boolean | angular.IPromise<boolean>;\n  }\n\n  /**\n   * Defines route lifecycle method `routerOnDeactivate`, which is called by the router before\n   * destroying\n   * a component as part of a route change.\n   *\n   * The `routerOnDeactivate` hook is called with two {@link ComponentInstruction}s as parameters, the\n   * first\n   * representing the current route being navigated to, and the second parameter representing the\n   * previous route.\n   *\n   * If `routerOnDeactivate` returns a IPromise, the route change will wait until the IPromise settles.\n   *\n   * ### Example\n   * {@example router/ts/on_deactivate/on_deactivate_example.ts region='routerOnDeactivate'}\n   */\n  export interface OnDeactivate {\n    $routerOnDeactivate(next?: ComponentInstruction, prev?: ComponentInstruction): any;\n  }\n\n  /**\n   * Defines route lifecycle method `routerCanReuse`, which is called by the router to determine\n   * whether a\n   * component should be reused across routes, or whether to destroy and instantiate a new component.\n   *\n   * The `routerCanReuse` hook is called with two {@link ComponentInstruction}s as parameters, the\n   * first\n   * representing the current route being navigated to, and the second parameter representing the\n   * previous route.\n   *\n   * If `routerCanReuse` returns or resolves to `true`, the component instance will be reused and the\n   * {@link OnDeactivate} hook will be run. If `routerCanReuse` returns or resolves to `false`, a new\n   * component will be instantiated, and the existing component will be deactivated and removed as\n   * part of the navigation.\n   *\n   * If `routerCanReuse` throws or rejects, the navigation will be cancelled.\n   *\n   * ### Example\n   * {@example router/ts/reuse/reuse_example.ts region='reuseCmp'}\n   */\n  export interface CanReuse {\n    $routerCanReuse(next?: ComponentInstruction, prev?: ComponentInstruction): boolean | angular.IPromise<boolean>;\n  }\n\n  /**\n   * Defines route lifecycle method `routerOnReuse`, which is called by the router at the end of a\n   * successful route navigation when {@link CanReuse} is implemented and returns or resolves to true.\n   *\n   * For a single component's navigation, only one of either {@link OnActivate} or {@link OnReuse}\n   * will be called, depending on the result of {@link CanReuse}.\n   *\n   * The `routerOnReuse` hook is called with two {@link ComponentInstruction}s as parameters, the\n   * first\n   * representing the current route being navigated to, and the second parameter representing the\n   * previous route or `null`.\n   *\n   * ### Example\n   * {@example router/ts/reuse/reuse_example.ts region='reuseCmp'}\n   */\n  export interface OnReuse {\n    $routerOnReuse(next?: ComponentInstruction, prev?: ComponentInstruction): any;\n  }\n\n  const componentProperties: string[] = [\n    'controller',\n    'controllerAs',\n    'bindings',\n    'require',\n    'template',\n    'templateUrl',\n    'transclude'\n  ];\n\n  export interface IComponentAnnotation {\n    (moduleName: string, componentName: string): IClassAnnotationDecorator;\n  }\n\n  /**\n   * inject a component\n   */\n  export function component(moduleName: string, componentName: string, componentConfig?: angular.IComponentOptions): at.IClassAnnotationDecorator {\n    return (target: any): void => {\n      let config: angular.IComponentOptions;\n\n      if (componentConfig) {\n        componentConfig.controller || (componentConfig.controller = target);\n        config = componentConfig;\n      } else {\n        config = componentProperties.reduce((\n          config: angular.IComponentOptions,\n          property: string\n        ) => {\n          return angular.isDefined(target[property]) ?\n            angular.extend(config, { [property]: target[property] }) :\n            config;\n        }, { controller: target });\n      }\n\n      getOrCreateModule(moduleName).component(componentName, config);\n    };\n  }\n\n  ///////////////////////////////////////////////////////////////////////////////\n  // DIRECTIVE ANNOTATION\n  ///////////////////////////////////////////////////////////////////////////////\n  const directiveProperties: string[] = [\n    'compile',\n    'controller',\n    'controllerAs',\n    'bindToController',\n    'link',\n    'priority',\n    'replace',\n    'require',\n    'restrict',\n    'scope',\n    'template',\n    'templateUrl',\n    'terminal',\n    'transclude'\n  ];\n\n  export interface IDirectiveAnnotation {\n    (moduleName: string, directiveName: string): IClassAnnotationDecorator;\n  }\n\n  /**\n   * inject a directive\n   */\n  export function directive(moduleName: string, directiveName: string, directiveConfig?: angular.IDirective): at.IClassAnnotationDecorator {\n    return (target: any): void => {\n      const ctrlCfg = directiveConfig ? directiveConfig.controller : target.controller;\n      let ctrlAs: string = directiveConfig ? directiveConfig.controllerAs : target.controllerAs;\n      if (ctrlCfg) {\n        const ctrlName: string = angular.isString(ctrlCfg) ? ctrlCfg.split(' ').shift() : null;\n        /* istanbul ignore else */\n        if (ctrlName) {\n          controller(moduleName, ctrlName)(target);\n        }\n      } else {\n        directiveConfig && (directiveConfig.controller = target);\n      }\n      if (!ctrlAs) {\n        ctrlAs = angular.isString(ctrlCfg) ? ctrlCfg.split(' ').pop() : null;\n        if (!ctrlAs) {\n          if (directiveConfig)\n            directiveConfig.controllerAs = 'vm';\n          else\n            target.controllerAs = 'vm';\n        }\n      }\n\n      let config: angular.IDirective;\n      if (directiveConfig) {\n        config = directiveConfig;\n      } else {\n        config = directiveProperties.reduce((\n          config: angular.IDirective,\n          property: string\n        ) => {\n          return angular.isDefined(target[property]) ? angular.extend(config, { [property]: target[property] }) :\n            config; /* istanbul ignore next */\n        }, { controller: target, scope: Boolean(target.templateUrl) });\n      }\n\n      getOrCreateModule(moduleName).directive(directiveName, () => (config));\n    };\n  }\n  /* tslint:enable:no-any */\n\n}\n"],"sourceRoot":"/source/"}