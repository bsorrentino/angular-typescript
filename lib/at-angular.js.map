{"version":3,"sources":["at-angular.ts"],"names":["at","at.attachInjects","at.getOrCreateModule","at.inject","at.injectMethod","at.action","at.failSafe","at.service","at.provider","at.filter","at.filter.Provider","at.filter.Provider.constructor","at.valueObj","at.valueProp","at.valueFunc","at.constantObj","at.constantProp","at.constantFunc","at.controller","at.component","at.directive"],"mappings":"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","file":"at-angular.js","sourcesContent":["module at {\r\n\r\n  'use strict';\r\n\r\n  /* tslint:disable:no-any */\r\n  export interface IClassAnnotationDecorator {\r\n    (target: any): void;\r\n    (t: any, key: string, index: number): void;\r\n  }\r\n\r\n  export interface IPropertyAnnotationDecorator {\r\n    (target: any, key: string): void;\r\n  }\r\n\r\n  export interface IMethodAnnotationDecorator {\r\n    (target: any, key: string, descriptor: TypedPropertyDescriptor<any>): void;\r\n  }\r\n\r\n  export function attachInjects(target: any, ...args: any[]): any {\r\n    (target.$inject || []).forEach((item: string, index: number) => {\r\n      target.prototype[(item.charAt(0) === '$' ? '$' : '$$') + item] = args[index];\r\n    });\r\n    return target;\r\n  }\r\n\r\n  /**\r\n   * return a module. If module doesn't exist it will be created\r\n   */\r\n  export function getOrCreateModule(moduleName: string, requires: string[] = []): angular.IModule {\r\n    let mod: angular.IModule;\r\n    try {\r\n      mod = angular.module(moduleName);\r\n    } catch (ex) {\r\n      mod = angular.module(moduleName, requires);\r\n    }\r\n\r\n    return mod;\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////////////////////////////\r\n  // INJECT ANNOTATION\r\n  ///////////////////////////////////////////////////////////////////////////////\r\n\r\n  export interface IInjectAnnotation {\r\n    (...args: any[]): IClassAnnotationDecorator;\r\n  }\r\n\r\n  /**\r\n   * inject an argument\r\n   */\r\n  export function inject(...args: string[]): at.IClassAnnotationDecorator {\r\n    return (target: any, key?: string, index?: number): void => {\r\n      if (angular.isNumber(index)) {\r\n        target.$inject = target.$inject || [];\r\n        target.$inject[index] = args[0];\r\n      } else {\r\n        target.$inject = args;\r\n      }\r\n    };\r\n  }\r\n\r\n  export function injectMethod(...args: string[]): at.IMethodAnnotationDecorator {\r\n    return (target: any, key: string, descriptor: TypedPropertyDescriptor<any>): void => {\r\n      target[key].$inject = args;\r\n    };\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////////////////////////////\r\n  // ERROR HANDLING ANNOTATION\r\n  ///////////////////////////////////////////////////////////////////////////////\r\n\r\n  export function action(description: string): at.IMethodAnnotationDecorator {\r\n    return (target: any, key: string, descriptor: TypedPropertyDescriptor<any>): void => {\r\n      target[key].description = description;\r\n    };\r\n  }\r\n\r\n  export function failSafe(moduleName: string, serviceName: string, handlerProviderName = 'exceptionHandlerProvider'): at.IClassAnnotationDecorator {\r\n      return (target: any): void => {\r\n          getOrCreateModule(moduleName).config([handlerProviderName, '$provide', (exceptionHandlerProvider, $provide) => {\r\n              exceptionHandlerProvider.decorate($provide, [serviceName]);\r\n          }]);\r\n      };\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////////////////////////////\r\n  // SERVICE ANNOTATION\r\n  ///////////////////////////////////////////////////////////////////////////////\r\n\r\n  export interface IServiceAnnotation {\r\n    (moduleName: string, serviceName: string): IClassAnnotationDecorator;\r\n  }\r\n\r\n  /**\r\n   * inject a service\r\n   */\r\n  export function service(moduleName: string, serviceName: string): at.IClassAnnotationDecorator {\r\n    return (target: any): void => {\r\n      getOrCreateModule(moduleName).service(serviceName, target);\r\n    };\r\n\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////////////////////////////\r\n  // PROVIDER ANNOTATION\r\n  ///////////////////////////////////////////////////////////////////////////////\r\n\r\n  export interface IProviderAnnotation {\r\n    (moduleName: string, providerName: string): IClassAnnotationDecorator;\r\n  }\r\n\r\n  /**\r\n   * inject a provider\r\n   */\r\n  export function provider(moduleName: string, providerName: string): at.IClassAnnotationDecorator {\r\n    return (target: any): void => {\r\n      getOrCreateModule(moduleName).provider(providerName, target);\r\n    };\r\n\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////////////////////////////\r\n  // FILTER ANNOTATION\r\n  ///////////////////////////////////////////////////////////////////////////////\r\n\r\n  export interface IFilter {\r\n    transform(input: any, ...args: any[]): any;\r\n  }\r\n\r\n  export interface IFilterAnnotation {\r\n    (moduleName: string, filterName: string): IClassAnnotationDecorator;\r\n  }\r\n\r\n  /**\r\n   * inject a provider\r\n   */\r\n  export function filter(moduleName: string, filterName: string): at.IClassAnnotationDecorator {\r\n    return (target: any): void => {\r\n      class Provider {\r\n        constructor() {\r\n          this.$get.$inject = (target.$inject || []).slice();\r\n        }\r\n        public $get = (...deps) => new target(...deps).transform;\r\n      }\r\n      getOrCreateModule(moduleName).provider(filterName + 'Filter', Provider);\r\n    };\r\n\r\n  }\r\n  ///////////////////////////////////////////////////////////////////////////////\r\n  // VALUE ANNOTATION\r\n  ///////////////////////////////////////////////////////////////////////////////\r\n\r\n  export interface IValueAnnotation {\r\n    (moduleName: string, valueName: string): IClassAnnotationDecorator;\r\n  }\r\n\r\n  export function valueObj(moduleName: string, valueName: string): at.IClassAnnotationDecorator {\r\n    return (target: any): void => {\r\n      getOrCreateModule(moduleName).value(valueName, target);\r\n    };\r\n  }\r\n\r\n  export function valueProp(moduleName: string, valueName?: string): at.IPropertyAnnotationDecorator {\r\n    return (target: any, key: string): void => {\r\n      getOrCreateModule(moduleName).value(valueName || key, target[key]);\r\n    };\r\n  }\r\n\r\n  export function valueFunc(moduleName: string, valueName?: string): at.IMethodAnnotationDecorator {\r\n    return (target: any, key: string, descriptor: TypedPropertyDescriptor<any>): void => {\r\n      getOrCreateModule(moduleName).value(valueName || key, target[key]);\r\n    };\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////////////////////////////\r\n  // CONSTANT ANNOTATION\r\n  ///////////////////////////////////////////////////////////////////////////////\r\n\r\n  export interface IConstantAnnotation {\r\n    (moduleName: string, valueName: string): IClassAnnotationDecorator;\r\n  }\r\n\r\n  export function constantObj(moduleName: string, valueName: string): at.IClassAnnotationDecorator {\r\n    return (target: any): void => {\r\n      getOrCreateModule(moduleName).constant(valueName, new target());\r\n    };\r\n  }\r\n\r\n  export function constantProp(moduleName: string, valueName?: string): at.IPropertyAnnotationDecorator {\r\n    return (target: any, key: string): void => {\r\n      getOrCreateModule(moduleName).constant(valueName || key, target[key]);\r\n    };\r\n  }\r\n\r\n  export function constantFunc(moduleName: string, valueName?: string): at.IMethodAnnotationDecorator {\r\n    return (target: any, key: string, descriptor: TypedPropertyDescriptor<any>): void => {\r\n      getOrCreateModule(moduleName).constant(valueName || key, target[key]);\r\n    };\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////////////////////////////\r\n  // CONTROLLER ANNOTATION\r\n  ///////////////////////////////////////////////////////////////////////////////\r\n\r\n  /**\r\n   * @link http://angular.github.io/router/lifecycle\r\n   */\r\n  export interface IController {\r\n    canActivate?(): boolean | angular.IPromise<boolean>;\r\n    activate?(): any;\r\n    canDeactivate?(): boolean | angular.IPromise<boolean>;\r\n    deactivate?(): any;\r\n  }\r\n\r\n  export interface IControllerAnnotation {\r\n    (moduleName: string, ctrlName: string): IClassAnnotationDecorator;\r\n  }\r\n\r\n  /**\r\n   * Inject a controller\r\n   */\r\n  export function controller(moduleName: string, ctrlName: string): at.IClassAnnotationDecorator {\r\n    return (target: any): void => {\r\n      getOrCreateModule(moduleName).controller(ctrlName, target);\r\n    };\r\n\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////////////////////////////\r\n  // COMPONENT ANNOTATION\r\n  ///////////////////////////////////////////////////////////////////////////////\r\n\r\n  export interface OnInit {\r\n    $onInit(): void;\r\n  }\r\n\r\n  export interface IChange<T> {\r\n      currentValue: T;\r\n      previousValue: T;\r\n      isFirstChange(): boolean;\r\n  }\r\n\r\n  export interface OnChanges {\r\n    $onChanges(changes: {[boundObjName: string]: IChange<any>}): void;\r\n  }\r\n\r\n  export interface OnDestroy {\r\n    $onDestroy(): void;\r\n  }\r\n\r\n  /**\r\n   * RouteData is an immutable map of additional data you can configure in your Route.\r\n   * You can inject RouteData into the constructor of a component to use it.\r\n   */\r\n  export interface RouteData {\r\n    data: { [key: string]: any };\r\n    get(key: string): any;\r\n  }\r\n\r\n  /**\r\n   * A `ComponentInstruction` represents the route state for a single component. An `Instruction` is\r\n   * composed of a tree of these `ComponentInstruction`s.\r\n   *\r\n   * `ComponentInstructions` is a public API. Instances of `ComponentInstruction` are passed\r\n   * to route lifecycle hooks, like {@link CanActivate}.\r\n   *\r\n   * `ComponentInstruction`s are [https://en.wikipedia.org/wiki/Hash_consing](hash consed). You should\r\n   * never construct one yourself with \"new.\" Instead, rely on {@link Router/RouteRecognizer} to\r\n   * construct `ComponentInstruction`s.\r\n   *\r\n   * You should not modify this object. It should be treated as immutable.\r\n   */\r\n  export interface ComponentInstruction {\r\n    reuse: boolean;\r\n    routeData: RouteData;\r\n    urlPath: string;\r\n    urlParams: string[];\r\n    data: RouteData;\r\n    componentType: any;\r\n    terminal: boolean;\r\n    specificity: number;\r\n    params: { [key: string]: any };\r\n  }\r\n\r\n  /**\r\n   * Defines route lifecycle method `routerOnActivate`, which is called by the router at the end of a\r\n   * successful route navigation.\r\n   *\r\n   * For a single component's navigation, only one of either {@link OnActivate} or {@link OnReuse}\r\n   * will be called depending on the result of {@link CanReuse}.\r\n   *\r\n   * The `routerOnActivate` hook is called with two {@link ComponentInstruction}s as parameters, the\r\n   * first\r\n   * representing the current route being navigated to, and the second parameter representing the\r\n   * previous route or `null`.\r\n   *\r\n   * If `routerOnActivate` returns a IPromise, the route change will wait until the IPromise settles to\r\n   * instantiate and activate child components.\r\n   *\r\n   * ### Example\r\n   * {@example router/ts/on_activate/on_activate_example.ts region='routerOnActivate'}\r\n   */\r\n  export interface OnActivate {\r\n    $routerOnActivate(next?: ComponentInstruction, prev?: ComponentInstruction): any;\r\n  }\r\n\r\n  /**\r\n   * Defines route lifecycle method `routerCanDeactivate`, which is called by the router to determine\r\n   * if a component can be removed as part of a navigation.\r\n   *\r\n   * The `routerCanDeactivate` hook is called with two {@link ComponentInstruction}s as parameters,\r\n   * the\r\n   * first representing the current route being navigated to, and the second parameter\r\n   * representing the previous route.\r\n   *\r\n   * If `routerCanDeactivate` returns or resolves to `false`, the navigation is cancelled. If it\r\n   * returns or\r\n   * resolves to `true`, then the navigation continues, and the component will be deactivated\r\n   * (the {@link OnDeactivate} hook will be run) and removed.\r\n   *\r\n   * If `routerCanDeactivate` throws or rejects, the navigation is also cancelled.\r\n   *\r\n   * ### Example\r\n   * {@example router/ts/can_deactivate/can_deactivate_example.ts region='routerCanDeactivate'}\r\n   */\r\n  export interface CanDeactivate {\r\n    $routerCanDeactivate(next?: ComponentInstruction, prev?: ComponentInstruction): boolean | angular.IPromise<boolean>;\r\n  }\r\n\r\n  /**\r\n   * Defines route lifecycle method `routerOnDeactivate`, which is called by the router before\r\n   * destroying\r\n   * a component as part of a route change.\r\n   *\r\n   * The `routerOnDeactivate` hook is called with two {@link ComponentInstruction}s as parameters, the\r\n   * first\r\n   * representing the current route being navigated to, and the second parameter representing the\r\n   * previous route.\r\n   *\r\n   * If `routerOnDeactivate` returns a IPromise, the route change will wait until the IPromise settles.\r\n   *\r\n   * ### Example\r\n   * {@example router/ts/on_deactivate/on_deactivate_example.ts region='routerOnDeactivate'}\r\n   */\r\n  export interface OnDeactivate {\r\n    $routerOnDeactivate(next?: ComponentInstruction, prev?: ComponentInstruction): any;\r\n  }\r\n\r\n  /**\r\n   * Defines route lifecycle method `routerCanReuse`, which is called by the router to determine\r\n   * whether a\r\n   * component should be reused across routes, or whether to destroy and instantiate a new component.\r\n   *\r\n   * The `routerCanReuse` hook is called with two {@link ComponentInstruction}s as parameters, the\r\n   * first\r\n   * representing the current route being navigated to, and the second parameter representing the\r\n   * previous route.\r\n   *\r\n   * If `routerCanReuse` returns or resolves to `true`, the component instance will be reused and the\r\n   * {@link OnDeactivate} hook will be run. If `routerCanReuse` returns or resolves to `false`, a new\r\n   * component will be instantiated, and the existing component will be deactivated and removed as\r\n   * part of the navigation.\r\n   *\r\n   * If `routerCanReuse` throws or rejects, the navigation will be cancelled.\r\n   *\r\n   * ### Example\r\n   * {@example router/ts/reuse/reuse_example.ts region='reuseCmp'}\r\n   */\r\n  export interface CanReuse {\r\n    $routerCanReuse(next?: ComponentInstruction, prev?: ComponentInstruction): boolean | angular.IPromise<boolean>;\r\n  }\r\n\r\n  /**\r\n   * Defines route lifecycle method `routerOnReuse`, which is called by the router at the end of a\r\n   * successful route navigation when {@link CanReuse} is implemented and returns or resolves to true.\r\n   *\r\n   * For a single component's navigation, only one of either {@link OnActivate} or {@link OnReuse}\r\n   * will be called, depending on the result of {@link CanReuse}.\r\n   *\r\n   * The `routerOnReuse` hook is called with two {@link ComponentInstruction}s as parameters, the\r\n   * first\r\n   * representing the current route being navigated to, and the second parameter representing the\r\n   * previous route or `null`.\r\n   *\r\n   * ### Example\r\n   * {@example router/ts/reuse/reuse_example.ts region='reuseCmp'}\r\n   */\r\n  export interface OnReuse {\r\n    $routerOnReuse(next?: ComponentInstruction, prev?: ComponentInstruction): any;\r\n  }\r\n\r\n  const componentProperties: string[] = [\r\n    'controller',\r\n    'controllerAs',\r\n    'bindings',\r\n    'require',\r\n    'template',\r\n    'templateUrl',\r\n    'transclude'\r\n  ];\r\n\r\n  export interface IComponentAnnotation {\r\n    (moduleName: string, componentName: string): IClassAnnotationDecorator;\r\n  }\r\n\r\n  /**\r\n   * inject a component\r\n   */\r\n  export function component(moduleName: string, componentName: string, componentConfig?: angular.IComponentOptions): at.IClassAnnotationDecorator {\r\n    return (target: any): void => {\r\n      let config: angular.IComponentOptions;\r\n\r\n      if (componentConfig) {\r\n        componentConfig.controller || (componentConfig.controller = target);\r\n        config = componentConfig;\r\n      } else {\r\n        config = componentProperties.reduce((\r\n          config: angular.IComponentOptions,\r\n          property: string\r\n        ) => {\r\n          return angular.isDefined(target[property]) ?\r\n            angular.extend(config, { [property]: target[property] }) :\r\n            config;\r\n        }, { controller: target });\r\n      }\r\n\r\n      getOrCreateModule(moduleName).component(componentName, config);\r\n    };\r\n  }\r\n\r\n  ///////////////////////////////////////////////////////////////////////////////\r\n  // DIRECTIVE ANNOTATION\r\n  ///////////////////////////////////////////////////////////////////////////////\r\n  const directiveProperties: string[] = [\r\n    'compile',\r\n    'controller',\r\n    'controllerAs',\r\n    'bindToController',\r\n    'link',\r\n    'priority',\r\n    'replace',\r\n    'require',\r\n    'restrict',\r\n    'scope',\r\n    'template',\r\n    'templateUrl',\r\n    'terminal',\r\n    'transclude'\r\n  ];\r\n\r\n  export interface IDirectiveAnnotation {\r\n    (moduleName: string, directiveName: string): IClassAnnotationDecorator;\r\n  }\r\n\r\n  /**\r\n   * inject a directive\r\n   */\r\n  export function directive(moduleName: string, directiveName: string, directiveConfig?: angular.IDirective): at.IClassAnnotationDecorator {\r\n    return (target: any): void => {\r\n      const ctrlCfg = directiveConfig ? directiveConfig.controller : target.controller;\r\n      let ctrlAs: string = directiveConfig ? directiveConfig.controllerAs : target.controllerAs;\r\n      if (ctrlCfg) {\r\n        const ctrlName: string = angular.isString(ctrlCfg) ? ctrlCfg.split(' ').shift() : null;\r\n        /* istanbul ignore else */\r\n        if (ctrlName) {\r\n          controller(moduleName, ctrlName)(target);\r\n        }\r\n      } else {\r\n        directiveConfig && (directiveConfig.controller = target);\r\n      }\r\n\r\n      // let attribute-directives not have ctrlAs by setting this property to 'false'\r\n      if (ctrlAs === undefined || ctrlAs === null) {\r\n        ctrlAs = angular.isString(ctrlCfg) ? ctrlCfg.split(' ').pop() : null;\r\n        if (!ctrlAs) {\r\n          if (directiveConfig) {\r\n            directiveConfig.controllerAs = 'vm';\r\n          } else {\r\n            target.controllerAs = 'vm';\r\n          }\r\n        }\r\n      }\r\n\r\n      let config: angular.IDirective;\r\n      if (directiveConfig) {\r\n        config = directiveConfig;\r\n      } else {\r\n        config = directiveProperties.reduce((\r\n          config: angular.IDirective,\r\n          property: string\r\n        ) => {\r\n          return angular.isDefined(target[property]) ? angular.extend(config, { [property]: target[property] }) :\r\n            config; /* istanbul ignore next */\r\n        }, { controller: target, scope: Boolean(target.templateUrl) });\r\n      }\r\n\r\n      getOrCreateModule(moduleName).directive(directiveName, () => (config));\r\n    };\r\n  }\r\n  /* tslint:enable:no-any */\r\n\r\n}\r\n"],"sourceRoot":"/source/"}